var searchIndex = {};
searchIndex['solicit'] = {"items":[[0,"","solicit","",null,null],[0,"http","","The module implements the framing layer of HTTP/2 and exposes an API for using it.",null,null],[3,"Response","solicit::http","A struct representing the full raw response received on an HTTP/2 connection.",null,null],[12,"stream_id","","The ID of the stream to which the response is associated. HTTP/1.1 does\nnot really have an equivalent to this.",0,null],[12,"headers","","Exposes *all* the raw response headers, including the meta-headers.\n(For now the only meta header allowed in HTTP/2 responses is the\n`:status`.)",0,null],[12,"body","","The full body of the response as an uninterpreted sequence of bytes.",0,null],[3,"Request","","A struct representing a full HTTP/2 request, along with the full body, as a\nsequence of bytes.",null,null],[12,"stream_id","","",1,null],[12,"headers","","",1,null],[12,"body","","",1,null],[4,"HttpError","","An enum representing errors that can arise when performing operations\ninvolving an HTTP/2 connection.",null,null],[13,"IoError","","",2,null],[13,"InvalidFrame","","",2,null],[13,"CompressionError","","",2,null],[13,"UnknownStreamId","","",2,null],[13,"UnableToConnect","","",2,null],[13,"MalformedResponse","","",2,null],[13,"Other","","",2,null],[4,"HttpScheme","","An enum representing the two possible HTTP schemes.",null,null],[13,"Http","","The variant corresponding to `http://`",3,null],[13,"Https","","The variant corresponding to `https://`",3,null],[0,"frame","","The module contains the implementation of HTTP/2 frames.",null,null],[3,"RawFrame","solicit::http::frame","A struct that defines the format of the raw HTTP/2 frame, i.e. the frame\nas it is read from the wire.",null,null],[5,"unpack_header","","Deconstructs a `FrameHeader` into its corresponding 4 components,\nrepresented as a 4-tuple: `(length, frame_type, flags, stream_id)`.",null,{"inputs":[{"name":"frameheaderbuffer"}],"output":{"name":"frameheader"}}],[5,"pack_header","","Constructs a buffer of 9 bytes that represents the given `FrameHeader`.",null,{"inputs":[{"name":"frameheader"}],"output":{"name":"frameheaderbuffer"}}],[0,"data","","The module contains the implementation of the `DATA` frame and associated flags.",null,null],[3,"DataFrame","solicit::http::frame::data","A struct representing the DATA frames of HTTP/2, as defined in the HTTP/2\nspec, section 6.1.",null,null],[12,"data","","The data found in the frame as an opaque byte sequence. It never\nincludes padding bytes.",4,null],[4,"DataFlag","","An enum representing the flags that a `DataFrame` can have.\nThe integer representation associated to each variant is that flag's\nbitmask.",null,null],[13,"EndStream","","",5,null],[13,"Padded","","",5,null],[11,"clone","","",5,{"inputs":[{"name":"dataflag"}],"output":{"name":"dataflag"}}],[11,"eq","","",5,{"inputs":[{"name":"dataflag"},{"name":"dataflag"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"dataflag"},{"name":"dataflag"}],"output":{"name":"bool"}}],[11,"fmt","","",5,{"inputs":[{"name":"dataflag"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"bitmask","","",5,{"inputs":[{"name":"dataflag"}],"output":{"name":"u8"}}],[11,"eq","","",4,{"inputs":[{"name":"dataframe"},{"name":"dataframe"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"dataframe"},{"name":"dataframe"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"dataframe"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"dataframe"}],"output":{"name":"dataframe"}}],[11,"new","","Creates a new empty `DataFrame`, associated to the stream with the\ngiven ID.",4,{"inputs":[{"name":"dataframe"},{"name":"streamid"}],"output":{"name":"dataframe"}}],[11,"is_padded","","Returns `true` if the DATA frame is padded, otherwise false.",4,{"inputs":[{"name":"dataframe"}],"output":{"name":"bool"}}],[11,"is_end_of_stream","","Returns whther this frame ends the stream it is associated with.",4,{"inputs":[{"name":"dataframe"}],"output":{"name":"bool"}}],[11,"set_padding","","Sets the number of bytes that should be used as padding for this\nframe.",4,{"inputs":[{"name":"dataframe"},{"name":"u8"}],"output":null}],[6,"FlagType","","",null,null],[11,"from_raw","","Creates a new `DataFrame` from the given `RawFrame` (i.e. header and\npayload), if possible.  Returns `None` if a valid `DataFrame` cannot be\nconstructed from the given `RawFrame`.",4,{"inputs":[{"name":"dataframe"},{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","Tests if the given flag is set for the frame.",4,{"inputs":[{"name":"dataframe"},{"name":"dataflag"}],"output":{"name":"bool"}}],[11,"set_flag","","Sets the given flag for the frame.",4,{"inputs":[{"name":"dataframe"},{"name":"dataflag"}],"output":null}],[11,"get_stream_id","","Returns the `StreamId` of the stream to which the frame is associated.",4,{"inputs":[{"name":"dataframe"}],"output":{"name":"streamid"}}],[11,"get_header","","Returns a `FrameHeader` based on the current state of the frame.",4,{"inputs":[{"name":"dataframe"}],"output":{"name":"frameheader"}}],[11,"serialize","","Returns a `Vec` with the serialized representation of the frame.",4,{"inputs":[{"name":"dataframe"}],"output":{"name":"vec"}}],[0,"headers","solicit::http::frame","The module contains the implementation of the `SETTINGS` frame and associated flags.",null,null],[3,"StreamDependency","solicit::http::frame::headers","The struct represents the dependency information that can be attached to\na stream and sent within a HEADERS frame (one with the Priority flag set).",null,null],[12,"stream_id","","The ID of the stream that a particular stream depends on",6,null],[12,"weight","","The weight for the stream. The value exposed (and set) here is always\nin the range [0, 255], instead of [1, 256] \\(as defined in section 5.3.2.)\nso that the value fits into a `u8`.",6,null],[12,"is_exclusive","","A flag indicating whether the stream dependency is exclusive.",6,null],[3,"HeadersFrame","","A struct representing the HEADERS frames of HTTP/2, as defined in the\nHTTP/2 spec, section 6.2.",null,null],[12,"header_fragment","","The header fragment bytes stored within the frame.",7,null],[12,"stream_id","","The ID of the stream with which this frame is associated",7,null],[12,"stream_dep","","The stream dependency information, if any.",7,null],[12,"padding_len","","The length of the padding, if any.",7,null],[4,"HeadersFlag","","An enum representing the flags that a `HeadersFrame` can have.\nThe integer representation associated to each variant is that flag's\nbitmask.",null,null],[13,"EndStream","","",8,null],[13,"EndHeaders","","",8,null],[13,"Padded","","",8,null],[13,"Priority","","",8,null],[11,"clone","","",8,{"inputs":[{"name":"headersflag"}],"output":{"name":"headersflag"}}],[11,"eq","","",8,{"inputs":[{"name":"headersflag"},{"name":"headersflag"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"headersflag"},{"name":"headersflag"}],"output":{"name":"bool"}}],[11,"fmt","","",8,{"inputs":[{"name":"headersflag"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"bitmask","","",8,{"inputs":[{"name":"headersflag"}],"output":{"name":"u8"}}],[11,"eq","","",6,{"inputs":[{"name":"streamdependency"},{"name":"streamdependency"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"streamdependency"},{"name":"streamdependency"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"streamdependency"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"streamdependency"}],"output":{"name":"streamdependency"}}],[11,"new","","Creates a new `StreamDependency` with the given stream ID, weight, and\nexclusivity.",6,{"inputs":[{"name":"streamdependency"},{"name":"streamid"},{"name":"u8"},{"name":"bool"}],"output":{"name":"streamdependency"}}],[11,"parse","","Parses the first 5 bytes in the buffer as a `StreamDependency`.\n(Each 5-byte sequence is always decodable into a stream dependency\nstructure).",6,null],[11,"serialize","","Serializes the `StreamDependency` into a 5-byte buffer representing the\ndependency description, as described in section 6.2. of the HTTP/2\nspec:",6,null],[11,"eq","","",7,{"inputs":[{"name":"headersframe"},{"name":"headersframe"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"headersframe"},{"name":"headersframe"}],"output":{"name":"bool"}}],[11,"fmt","","",7,{"inputs":[{"name":"headersframe"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"headersframe"}],"output":{"name":"headersframe"}}],[11,"new","","Creates a new `HeadersFrame` with the given header fragment and stream\nID. No padding, no stream dependency, and no flags are set.",7,{"inputs":[{"name":"headersframe"},{"name":"vec"},{"name":"streamid"}],"output":{"name":"headersframe"}}],[11,"with_dependency","","Creates a new `HeadersFrame` with the given header fragment, stream ID\nand stream dependency information. No padding and no flags are set.",7,{"inputs":[{"name":"headersframe"},{"name":"vec"},{"name":"streamid"},{"name":"streamdependency"}],"output":{"name":"headersframe"}}],[11,"is_headers_end","","Returns whether this frame ends the headers. If not, there MUST be a\nnumber of follow up CONTINUATION frames that send the rest of the\nheader data.",7,{"inputs":[{"name":"headersframe"}],"output":{"name":"bool"}}],[11,"is_end_of_stream","","Returns whther this frame ends the stream it is associated with.",7,{"inputs":[{"name":"headersframe"}],"output":{"name":"bool"}}],[11,"set_padding","","Sets the padding length for the frame, as well as the corresponding\nPadded flag.",7,{"inputs":[{"name":"headersframe"},{"name":"u8"}],"output":null}],[6,"FlagType","","The type that represents the flags that the particular `Frame` can take.\nThis makes sure that only valid `Flag`s are used with each `Frame`.",null,null],[11,"from_raw","","Creates a new `HeadersFrame` with the given `RawFrame` (i.e. header and\npayload), if possible.",7,{"inputs":[{"name":"headersframe"},{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","Tests if the given flag is set for the frame.",7,{"inputs":[{"name":"headersframe"},{"name":"headersflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","Returns the `StreamId` of the stream to which the frame is associated.",7,{"inputs":[{"name":"headersframe"}],"output":{"name":"streamid"}}],[11,"get_header","","Returns a `FrameHeader` based on the current state of the `Frame`.",7,{"inputs":[{"name":"headersframe"}],"output":{"name":"frameheader"}}],[11,"set_flag","","Sets the given flag for the frame.",7,{"inputs":[{"name":"headersframe"},{"name":"headersflag"}],"output":null}],[11,"serialize","","Returns a `Vec` with the serialized representation of the frame.",7,{"inputs":[{"name":"headersframe"}],"output":{"name":"vec"}}],[0,"settings","solicit::http::frame","The module contains the implementation of the `SETTINGS` frame and associated flags.",null,null],[3,"SettingsFrame","solicit::http::frame::settings","A struct representing the SETTINGS frames of HTTP/2, as defined in the\nHTTP/2 spec, section 6.5.",null,null],[12,"settings","","Contains all the settings that are currently set in the frame. It is\nsafe to access this field (to read, add, or remove settings), even\nthough a helper method `add_setting` exists.",9,null],[4,"HttpSetting","","An enum that lists all valid settings that can be sent in a SETTINGS\nframe.",null,null],[13,"HeaderTableSize","","",10,null],[13,"EnablePush","","",10,null],[13,"MaxConcurrentStreams","","",10,null],[13,"InitialWindowSize","","",10,null],[13,"MaxFrameSize","","",10,null],[13,"MaxHeaderListSize","","",10,null],[4,"SettingsFlag","","An enum representing the flags that a `SettingsFrame` can have.\nThe integer representation associated to each variant is that flag's\nbitmask.",null,null],[13,"Ack","","",11,null],[11,"clone","","",10,{"inputs":[{"name":"httpsetting"}],"output":{"name":"httpsetting"}}],[11,"eq","","",10,{"inputs":[{"name":"httpsetting"},{"name":"httpsetting"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"httpsetting"},{"name":"httpsetting"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"httpsetting"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_id","","Creates a new `HttpSetting` with the correct variant corresponding to\nthe given setting id, based on the settings IDs defined in section\n6.5.2.",10,{"inputs":[{"name":"httpsetting"},{"name":"u16"},{"name":"u32"}],"output":{"name":"option"}}],[11,"get_id","","Returns the setting ID as an unsigned 16 bit integer, as defined in\nsection 6.5.2.",10,{"inputs":[{"name":"httpsetting"}],"output":{"name":"u16"}}],[11,"get_val","","Gets the setting value by unpacking it from the wrapped `u32`.",10,{"inputs":[{"name":"httpsetting"}],"output":{"name":"u32"}}],[11,"clone","","",11,{"inputs":[{"name":"settingsflag"}],"output":{"name":"settingsflag"}}],[11,"eq","","",11,{"inputs":[{"name":"settingsflag"},{"name":"settingsflag"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"settingsflag"},{"name":"settingsflag"}],"output":{"name":"bool"}}],[11,"fmt","","",11,{"inputs":[{"name":"settingsflag"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"bitmask","","",11,{"inputs":[{"name":"settingsflag"}],"output":{"name":"u8"}}],[11,"eq","","",9,{"inputs":[{"name":"settingsframe"},{"name":"settingsframe"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"settingsframe"},{"name":"settingsframe"}],"output":{"name":"bool"}}],[11,"fmt","","",9,{"inputs":[{"name":"settingsframe"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"settingsframe"}],"output":{"name":"settingsframe"}}],[11,"new","","Creates a new `SettingsFrame`",9,{"inputs":[{"name":"settingsframe"}],"output":{"name":"settingsframe"}}],[11,"new_ack","","A convenience constructor that returns a `SettingsFrame` with the ACK\nflag already set and no settings.",9,{"inputs":[{"name":"settingsframe"}],"output":{"name":"settingsframe"}}],[11,"add_setting","","Adds the given setting to the frame.",9,{"inputs":[{"name":"settingsframe"},{"name":"httpsetting"}],"output":null}],[11,"set_ack","","Sets the ACK flag for the frame. This method is just a convenience\nmethod for calling `frame.set_flag(SettingsFlag::Ack)`.",9,{"inputs":[{"name":"settingsframe"}],"output":null}],[11,"is_ack","","Checks whether the `SettingsFrame` has an ACK attached to it.",9,{"inputs":[{"name":"settingsframe"}],"output":{"name":"bool"}}],[6,"FlagType","","The type that represents the flags that the particular `Frame` can take.\nThis makes sure that only valid `Flag`s are used with each `Frame`.",null,null],[11,"from_raw","","Creates a new `SettingsFrame` with the given `RawFrame` (i.e. header and\npayload), if possible.",9,{"inputs":[{"name":"settingsframe"},{"name":"rawframe"}],"output":{"name":"option"}}],[11,"is_set","","Tests if the given flag is set for the frame.",9,{"inputs":[{"name":"settingsframe"},{"name":"settingsflag"}],"output":{"name":"bool"}}],[11,"get_stream_id","","Returns the `StreamId` of the stream to which the frame is associated.",9,{"inputs":[{"name":"settingsframe"}],"output":{"name":"streamid"}}],[11,"get_header","","Returns a `FrameHeader` based on the current state of the `Frame`.",9,{"inputs":[{"name":"settingsframe"}],"output":{"name":"frameheader"}}],[11,"set_flag","","Sets the given flag for the frame.",9,{"inputs":[{"name":"settingsframe"},{"name":"settingsflag"}],"output":null}],[11,"serialize","","Returns a `Vec` with the serialized representation of the frame.",9,{"inputs":[{"name":"settingsframe"}],"output":{"name":"vec"}}],[6,"FrameHeaderBuffer","solicit::http::frame","An alias for the 9-byte buffer that each HTTP/2 frame header must be stored\nin.",null,null],[6,"FrameHeader","","An alias for the 4-tuple representing the components of each HTTP/2 frame\nheader.",null,null],[8,"Flag","","A trait that all HTTP/2 frame header flags need to implement.",null,null],[10,"bitmask","","Returns a bit mask that represents the flag.",12,{"inputs":[{"name":"flag"}],"output":{"name":"u8"}}],[8,"Frame","","A trait that all HTTP/2 frame structs need to implement.",null,null],[16,"FlagType","","The type that represents the flags that the particular `Frame` can take.\nThis makes sure that only valid `Flag`s are used with each `Frame`.",13,null],[10,"from_raw","","Creates a new `Frame` from the given `RawFrame` (i.e. header and\npayload), if possible.",13,{"inputs":[{"name":"frame"},{"name":"rawframe"}],"output":{"name":"option"}}],[10,"is_set","","Tests if the given flag is set for the frame.",13,{"inputs":[{"name":"frame"},{"name":"flagtype"}],"output":{"name":"bool"}}],[10,"get_stream_id","","Returns the `StreamId` of the stream to which the frame is associated",13,{"inputs":[{"name":"frame"}],"output":{"name":"streamid"}}],[10,"get_header","","Returns a `FrameHeader` based on the current state of the `Frame`.",13,{"inputs":[{"name":"frame"}],"output":{"name":"frameheader"}}],[10,"set_flag","","Sets the given flag for the frame.",13,{"inputs":[{"name":"frame"},{"name":"flagtype"}],"output":null}],[10,"serialize","","Returns a `Vec` with the serialized representation of the frame.",13,{"inputs":[{"name":"frame"}],"output":{"name":"vec"}}],[11,"eq","","",14,{"inputs":[{"name":"rawframe"},{"name":"rawframe"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"rawframe"},{"name":"rawframe"}],"output":{"name":"bool"}}],[11,"fmt","","",14,{"inputs":[{"name":"rawframe"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"rawframe"}],"output":{"name":"rawframe"}}],[11,"new","","Creates a new `RawFrame` with the given `FrameHeader`. The payload is\nleft empty.",14,{"inputs":[{"name":"rawframe"},{"name":"frameheader"}],"output":{"name":"rawframe"}}],[11,"with_payload","","Creates a new `RawFrame` with the given header and payload.\nDoes not do any validation to determine whether the frame is in a correct\nstate as constructed.",14,{"inputs":[{"name":"rawframe"},{"name":"frameheader"},{"name":"vec"}],"output":{"name":"rawframe"}}],[11,"from_buf","","Creates a new `RawFrame` by parsing the given buffer.",14,null],[11,"serialize","","Returns a `Vec` of bytes representing the serialized (on-the-wire)\nrepresentation of this raw frame.",14,{"inputs":[{"name":"rawframe"}],"output":{"name":"vec"}}],[11,"header","","Returns a `FrameHeader` instance corresponding to the headers of the\n`RawFrame`.",14,{"inputs":[{"name":"rawframe"}],"output":{"name":"frameheader"}}],[11,"payload","","Returns a slice representing the payload of the `RawFrame`.",14,null],[11,"into","","",14,{"inputs":[{"name":"rawframe"}],"output":{"name":"vec"}}],[11,"from","","",14,{"inputs":[{"name":"rawframe"},{"name":"vec"}],"output":{"name":"rawframe"}}],[0,"transport","solicit::http","The module contains implementations of the transport layer functionality\nthat HTTP/2 requires. It exposes APIs that allow the HTTP/2 connection to\nuse the transport layer without requiring it to know which exact\nimplementation they are using (e.g. a clear-text TCP connection, a TLS\nprotected connection, or even a mock implementation).",null,null],[8,"TransportStream","solicit::http::transport","A trait that any struct that wants to provide the transport layer for\nHTTP/2 needs to implement.",null,null],[11,"read_exact","","A convenience method that performs as many `read` calls on the\nunderlying `Read` implementation as it takes to fill the given buffer.",15,null],[10,"try_split","","Attempts to split the `TransportStream` instance into a new independently\nowned handle to the same underlying stream.",15,{"inputs":[{"name":"transportstream"}],"output":{"name":"result"}}],[10,"close","","Attempts to shutdown both ends of the transport stream.",15,{"inputs":[{"name":"transportstream"}],"output":{"name":"result"}}],[11,"try_split","std::net::tcp","",16,{"inputs":[{"name":"tcpstream"}],"output":{"name":"result"}}],[11,"close","","",16,{"inputs":[{"name":"tcpstream"}],"output":{"name":"result"}}],[11,"try_split","openssl::ssl","",17,{"inputs":[{"name":"sslstream"}],"output":{"name":"result"}}],[11,"close","","",17,{"inputs":[{"name":"sslstream"}],"output":{"name":"result"}}],[0,"connection","solicit::http","The module contains the implementation of an HTTP/2 connection.",null,null],[3,"HttpConnection","solicit::http::connection","The struct implements the HTTP/2 connection level logic.",null,null],[12,"receiver","","The instance handling the reading of frames.",18,null],[12,"sender","","The instance handling the writing of frames.",18,null],[12,"scheme","","The scheme of the connection",18,null],[3,"DataChunk","","The struct represents a chunk of data that should be sent to the peer on a particular stream.",null,null],[12,"data","","The data that should be sent.",19,null],[12,"stream_id","","The ID of the stream on which the data should be sent.",19,null],[12,"end_stream","","Whether the data chunk will also end the stream.",19,null],[4,"HttpFrame","","An enum representing all frame variants that can be returned by an\n`HttpConnection`.",null,null],[13,"DataFrame","","",20,null],[13,"HeadersFrame","","",20,null],[13,"SettingsFrame","","",20,null],[13,"UnknownFrame","","",20,null],[4,"SendStatus","","The enum represents the success status of the operation of sending a next data chunk on an\nHTTP/2 connection.",null,null],[13,"Sent","","Indicates that a DATA frame was successfully sent",21,null],[13,"Nothing","","Indicates that nothing was sent, but that no errors occurred.",21,null],[4,"EndStream","","An enum indicating whether the `HttpConnection` send operation should end the stream.",null,null],[13,"Yes","","The stream should be closed",22,null],[13,"No","","The stream should still be kept open",22,null],[8,"SendFrame","","A trait that should be implemented by types that can provide the functionality\nof sending HTTP/2 frames.",null,null],[10,"send_raw_frame","","Sends the given raw frame.",23,{"inputs":[{"name":"sendframe"},{"name":"rawframe"}],"output":{"name":"httpresult"}}],[11,"send_frame","","Sends the given concrete frame.",23,{"inputs":[{"name":"sendframe"},{"name":"f"}],"output":{"name":"httpresult"}}],[8,"ReceiveFrame","","A trait that should be implemented by types that can provide the functionality\nof receiving HTTP/2 frames.",null,null],[10,"recv_frame","","Return a new `HttpFrame` instance. Unknown frames can be wrapped in the\n`HttpFrame::UnknownFrame` variant (i.e. their `RawFrame` representation).",24,{"inputs":[{"name":"receiveframe"}],"output":{"name":"httpresult"}}],[11,"eq","","",20,{"inputs":[{"name":"httpframe"},{"name":"httpframe"}],"output":{"name":"bool"}}],[11,"ne","","",20,{"inputs":[{"name":"httpframe"},{"name":"httpframe"}],"output":{"name":"bool"}}],[11,"fmt","","",20,{"inputs":[{"name":"httpframe"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",20,{"inputs":[{"name":"httpframe"}],"output":{"name":"httpframe"}}],[11,"from_raw","","",20,{"inputs":[{"name":"httpframe"},{"name":"rawframe"}],"output":{"name":"httpresult"}}],[11,"fmt","","",21,{"inputs":[{"name":"sendstatus"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",21,{"inputs":[{"name":"sendstatus"},{"name":"sendstatus"}],"output":{"name":"bool"}}],[11,"ne","","",21,{"inputs":[{"name":"sendstatus"},{"name":"sendstatus"}],"output":{"name":"bool"}}],[11,"clone","","",21,{"inputs":[{"name":"sendstatus"}],"output":{"name":"sendstatus"}}],[11,"new","","Creates a new `DataChunk`.",19,{"inputs":[{"name":"datachunk"},{"name":"cow"},{"name":"streamid"},{"name":"endstream"}],"output":{"name":"datachunk"}}],[11,"new_borrowed","","Creates a new `DataChunk` from a borrowed slice. This method should become obsolete if we\ncan take an `Into<Cow<_, _>>` without using unstable features.",19,{"inputs":[{"name":"datachunk"},{"name":"d"},{"name":"streamid"},{"name":"endstream"}],"output":{"name":"datachunk"}}],[11,"fmt","","",22,{"inputs":[{"name":"endstream"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",22,{"inputs":[{"name":"endstream"},{"name":"endstream"}],"output":{"name":"bool"}}],[11,"ne","","",22,{"inputs":[{"name":"endstream"},{"name":"endstream"}],"output":{"name":"bool"}}],[11,"clone","","",22,{"inputs":[{"name":"endstream"}],"output":{"name":"endstream"}}],[11,"new","","Creates a new `HttpConnection` that will use the given sender and receiver instances\nfor writing and reading frames, respectively.",18,{"inputs":[{"name":"httpconnection"},{"name":"s"},{"name":"r"},{"name":"httpscheme"}],"output":{"name":"httpconnection"}}],[11,"with_stream","","Creates a new `HttpConnection` that will use the given stream as its\nunderlying transport layer.",18,{"inputs":[{"name":"httpconnection"},{"name":"ts"},{"name":"httpscheme"}],"output":{"name":"httpconnection"}}],[11,"send_headers","","A helper function that inserts the frames required to send the given headers onto the\n`SendFrame` stream.",18,{"inputs":[{"name":"httpconnection"},{"name":"h"},{"name":"streamid"},{"name":"endstream"}],"output":{"name":"httpresult"}}],[11,"send_data","","A helper function that inserts a frame representing the given data into the `SendFrame`\nstream.",18,{"inputs":[{"name":"httpconnection"},{"name":"datachunk"}],"output":{"name":"httpresult"}}],[11,"send_next_data","","Sends the chunk of data provided by the given `DataPrioritizer`.",18,{"inputs":[{"name":"httpconnection"},{"name":"p"}],"output":{"name":"httpresult"}}],[11,"expect_settings","","The method processes the next incoming frame, expecting it to be a SETTINGS frame.\nAdditionally, the frame cannot be an ACK settings frame, but rather it should contain the\npeer's settings.",18,{"inputs":[{"name":"httpconnection"},{"name":"sess"}],"output":{"name":"httpresult"}}],[11,"handle_next_frame","","Handles the next frame incoming on the `ReceiveFrame` instance.",18,{"inputs":[{"name":"httpconnection"},{"name":"sess"}],"output":{"name":"httpresult"}}],[0,"session","solicit::http","Defines the interface for the session-level management of HTTP/2\ncommunication. This is effectively an API that allows hooking into an\nHTTP/2 connection in order to handle events arising on the connection.",null,null],[3,"StreamIter","solicit::http::session","A newtype for an iterator over `Stream`s saved in a `SessionState`.",null,null],[3,"DefaultSessionState","","An implementation of the `SessionState` trait that tracks the active streams in a `HashMap`,\nmapping the stream ID to the concrete `Stream` instance.",null,null],[3,"DefaultStream","","An implementation of the `Stream` trait that saves all headers and data\nin memory.",null,null],[12,"stream_id","","The ID of the stream",25,null],[12,"headers","","The headers associated with the stream (i.e. the response headers)",25,null],[12,"body","","The body of the stream (i.e. the response body)",25,null],[12,"state","","The current stream state.",25,null],[4,"StreamState","","The enum represents all the states that an HTTP/2 stream can be found in.",null,null],[13,"Idle","","",26,null],[13,"ReservedLocal","","",26,null],[13,"ReservedRemote","","",26,null],[13,"Open","","",26,null],[13,"HalfClosedRemote","","",26,null],[13,"HalfClosedLocal","","",26,null],[13,"Closed","","",26,null],[4,"StreamDataError","","The enum represents errors that can be returned from the `Stream::get_data_chunk` method.",null,null],[13,"Closed","","Indicates that the stream cannot provide any data, since it is closed for further writes\nfrom the peer's side.",27,null],[13,"Other","","A different error while trying to obtain the data chunk. Wraps a boxed `Error` impl.",27,null],[4,"StreamDataChunk","","The enum represents the successful completion of the `Stream::get_data_chunk` method.",null,null],[13,"Chunk","","A data chunk of the given size, after which more chunks can follow.",28,null],[13,"Last","","The chunk was the last one that the stream will ever write.",28,null],[13,"Unavailable","","No data currently available, but the stream isn't closed yet",28,null],[8,"Session","","A trait that defines the interface between an `HttpConnection` and the higher-levels that use\nit. Essentially, it allows the `HttpConnection` to pass information onto those higher levels\nthrough a well-defined interface.",null,null],[10,"new_data_chunk","","Notifies the `Session` that a new data chunk has arrived on the\nconnection for a particular stream. Only the raw data is passed\nto the callback (all padding is already discarded by the connection).",29,null],[10,"new_headers","","Notifies the `Session` that headers have arrived for a particular\nstream. The given list of headers is already decoded by the connection.",29,{"inputs":[{"name":"session"},{"name":"streamid"},{"name":"vec"}],"output":null}],[10,"end_of_stream","","Notifies the `Session` that a particular stream got closed by the peer.",29,{"inputs":[{"name":"session"},{"name":"streamid"}],"output":null}],[8,"SessionState","","A trait defining a set of methods for accessing and influencing an HTTP/2 session's state.",null,null],[16,"Stream","","The type of the `Stream` that the `SessionState` manages.",30,null],[10,"insert_stream","","Inserts the given `Stream` into the session's state, starting to track it.",30,{"inputs":[{"name":"sessionstate"},{"name":"stream"}],"output":null}],[10,"get_stream_ref","","Returns a reference to a `Stream` with the given `StreamId`, if it is found in the current\nsession.",30,{"inputs":[{"name":"sessionstate"},{"name":"streamid"}],"output":{"name":"option"}}],[10,"get_stream_mut","","Returns a mutable reference to a `Stream` with the given `StreamId`, if it is found in the\ncurrent session.",30,{"inputs":[{"name":"sessionstate"},{"name":"streamid"}],"output":{"name":"option"}}],[10,"remove_stream","","Removes the stream with the given `StreamId` from the session. If the stream was found in\nthe session, it is returned in the result.",30,{"inputs":[{"name":"sessionstate"},{"name":"streamid"}],"output":{"name":"option"}}],[10,"iter","","Returns an iterator over the streams currently found in the session.",30,{"inputs":[{"name":"sessionstate"}],"output":{"name":"streamiter"}}],[11,"get_closed","","Returns all streams that are closed and tracked by the session state.",30,{"inputs":[{"name":"sessionstate"}],"output":{"name":"vec"}}],[8,"Stream","","A trait representing a single HTTP/2 stream. An HTTP/2 connection multiplexes a number of\nstreams.",null,null],[10,"new","","Create a new stream with the given ID",31,{"inputs":[{"name":"stream"},{"name":"streamid"}],"output":{"name":"self"}}],[10,"new_data_chunk","","Handle a new data chunk that has arrived for the stream.",31,null],[10,"set_headers","","Set headers for a stream. A stream is only allowed to have one set of\nheaders.",31,{"inputs":[{"name":"stream"},{"name":"vec"}],"output":null}],[10,"set_state","","Sets the stream state to the newly provided state.",31,{"inputs":[{"name":"stream"},{"name":"streamstate"}],"output":null}],[10,"get_data_chunk","","Places the next data chunk that should be written onto the stream into the given buffer.",31,null],[10,"id","","Returns the ID of the stream.",31,{"inputs":[{"name":"stream"}],"output":{"name":"streamid"}}],[10,"state","","Returns the current state of the stream.",31,{"inputs":[{"name":"stream"}],"output":{"name":"streamstate"}}],[11,"close","","Transitions the stream state to closed. After this, the stream is considered to be closed\nfor any further reads or writes.",31,{"inputs":[{"name":"stream"}],"output":null}],[11,"close_local","","Updates the `Stream` status to indicate that it is closed locally.",31,{"inputs":[{"name":"stream"}],"output":null}],[11,"close_remote","","Updates the `Stream` status to indicate that it is closed on the remote peer's side.",31,{"inputs":[{"name":"stream"}],"output":null}],[11,"is_closed","","Returns whether the stream is closed.",31,{"inputs":[{"name":"stream"}],"output":{"name":"bool"}}],[11,"is_closed_local","","Returns whether the stream is closed locally.",31,{"inputs":[{"name":"stream"}],"output":{"name":"bool"}}],[11,"is_closed_remote","","Returns whether the remote peer has closed the stream. This includes a fully closed stream.",31,{"inputs":[{"name":"stream"}],"output":{"name":"bool"}}],[6,"Item","","",null,null],[11,"next","","",32,{"inputs":[{"name":"streamiter"}],"output":{"name":"option"}}],[11,"new","","Creates a new `DefaultSessionState` with no known streams.",33,{"inputs":[{"name":"defaultsessionstate"}],"output":{"name":"defaultsessionstate"}}],[6,"Stream","","",null,null],[11,"insert_stream","","",33,{"inputs":[{"name":"defaultsessionstate"},{"name":"stream"}],"output":null}],[11,"get_stream_ref","","",33,{"inputs":[{"name":"defaultsessionstate"},{"name":"streamid"}],"output":{"name":"option"}}],[11,"get_stream_mut","","",33,{"inputs":[{"name":"defaultsessionstate"},{"name":"streamid"}],"output":{"name":"option"}}],[11,"remove_stream","","",33,{"inputs":[{"name":"defaultsessionstate"},{"name":"streamid"}],"output":{"name":"option"}}],[11,"iter","","",33,{"inputs":[{"name":"defaultsessionstate"}],"output":{"name":"streamiter"}}],[11,"fmt","","",26,{"inputs":[{"name":"streamstate"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",26,{"inputs":[{"name":"streamstate"},{"name":"streamstate"}],"output":{"name":"bool"}}],[11,"ne","","",26,{"inputs":[{"name":"streamstate"},{"name":"streamstate"}],"output":{"name":"bool"}}],[11,"clone","","",26,{"inputs":[{"name":"streamstate"}],"output":{"name":"streamstate"}}],[11,"fmt","","",27,{"inputs":[{"name":"streamdataerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",27,{"inputs":[{"name":"streamdataerror"},{"name":"e"}],"output":{"name":"streamdataerror"}}],[11,"fmt","","",28,{"inputs":[{"name":"streamdatachunk"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",28,{"inputs":[{"name":"streamdatachunk"},{"name":"streamdatachunk"}],"output":{"name":"bool"}}],[11,"ne","","",28,{"inputs":[{"name":"streamdatachunk"},{"name":"streamdatachunk"}],"output":{"name":"bool"}}],[11,"clone","","",28,{"inputs":[{"name":"streamdatachunk"}],"output":{"name":"streamdatachunk"}}],[11,"clone","","",25,{"inputs":[{"name":"defaultstream"}],"output":{"name":"defaultstream"}}],[11,"new","","Create a new `DefaultStream` with the given ID.",25,{"inputs":[{"name":"defaultstream"},{"name":"streamid"}],"output":{"name":"defaultstream"}}],[11,"set_full_data","","Sets the outgoing data of the stream to the given `Vec`.",25,{"inputs":[{"name":"defaultstream"},{"name":"vec"}],"output":null}],[11,"new","","",25,{"inputs":[{"name":"defaultstream"},{"name":"streamid"}],"output":{"name":"defaultstream"}}],[11,"new_data_chunk","","",25,null],[11,"set_headers","","",25,{"inputs":[{"name":"defaultstream"},{"name":"vec"}],"output":null}],[11,"set_state","","",25,{"inputs":[{"name":"defaultstream"},{"name":"streamstate"}],"output":null}],[11,"id","","",25,{"inputs":[{"name":"defaultstream"}],"output":{"name":"streamid"}}],[11,"state","","",25,{"inputs":[{"name":"defaultstream"}],"output":{"name":"streamstate"}}],[11,"get_data_chunk","","",25,null],[0,"priority","solicit::http","The module exposes an API for defining data prioritization strategies.",null,null],[3,"SimplePrioritizer","solicit::http::priority","An implementation of the `DataPrioritizer` trait that is based on finding the first stream from\nthe given `SessionState` instance that can send data and returning this chunk.",null,null],[8,"DataPrioritizer","","A trait that types that want to provide data to an HTTP/2 connection need to implement.",null,null],[10,"get_next_chunk","","Returns the next `DataChunk` that should be sent on the HTTP/2 connection. `None` indicates\nthat currently there was no data that could be sent at that point.",34,{"inputs":[{"name":"dataprioritizer"}],"output":{"name":"httpresult"}}],[11,"new","","Creates a new `SimplePrioritizer` that will use the given state to find stream data that\nshould be sent and use the given buffer to hold the data of the returned chunk.",35,null],[11,"get_next_chunk","","",35,{"inputs":[{"name":"simpleprioritizer"}],"output":{"name":"httpresult"}}],[0,"client","solicit::http","The module contains a number of reusable components for implementing the client side of an\nHTTP/2 connection.",null,null],[3,"ClientStream","solicit::http::client","A convenience wrapper type that represents an established client network transport stream.\nIt wraps the stream itself, the scheme of the protocol to be used, and the remote\nhost name.",null,null],[3,"CleartextConnector","","A struct that establishes a cleartext TCP connection that can be used by an HTTP/2\nconnection. Defaults to using port 80.",null,null],[12,"host","","The host to which the connection should be established",36,null],[12,"port","","The port on which the connection should be established",36,null],[3,"CleartextConnectError","","A newtype wrapping the `io::Error`, as it occurs when attempting to\nestablish an HTTP/2 connection over cleartext TCP (with prior knowledge).",null,null],[3,"RequestStream","","A struct representing a request stream. It provides the headers that are to be sent when\ninitiating the request, as well as a `Stream` instance that handles the received response and\nprovides the request body.",null,null],[12,"headers","","The list of headers that will be sent with the request.",37,null],[12,"stream","","The underlying `Stream` instance, which will handle the response, as well as optionally\nprovide the body of the request.",37,null],[3,"ClientConnection","","The struct extends the `HttpConnection` API with client-specific methods (such as\n`start_request`) and wires the `HttpConnection` to the client `Session` callbacks.",null,null],[12,"state","","The state of the session associated to this client connection. Maintains the status of the\nconnection streams.",38,null],[3,"ClientSession","","An implementation of the `Session` trait specific to handling client HTTP/2 connections.",null,null],[5,"write_preface","","Writes the client preface to the underlying HTTP/2 connection.",null,{"inputs":[{"name":"w"}],"output":{"name":"result"}}],[0,"tls","","The module contains helpers for implementing TLS-based client connections.",null,null],[3,"TlsConnector","solicit::http::client::tls","A struct implementing the functionality of establishing a TLS-backed TCP stream\nthat can be used by an HTTP/2 connection. Takes care to set all the TLS options\nto those allowed by the HTTP/2 spec, as well as of the protocol negotiation.",null,null],[12,"host","","",39,null],[4,"TlsConnectError","","An enum representing possible errors that can arise when trying to\nestablish an HTTP/2 connection over TLS.",null,null],[13,"IoError","","The variant corresponds to the underlying raw TCP connection returning\nan error.",40,null],[13,"SslError","","The variant corresponds to the TLS negotiation returning an error.",40,null],[13,"Http2NotSupported","","The variant corresponds to the case when the TLS connection is\nestablished, but the application protocol that was negotiated didn't\nend up being HTTP/2.\nIt wraps the established SSL stream in order to allow the client to\ndecide what to do with it (and the application protocol that was\nchosen).",40,null],[11,"fmt","","",40,{"inputs":[{"name":"tlsconnecterror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",40,{"inputs":[{"name":"tlsconnecterror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",40,{"inputs":[{"name":"tlsconnecterror"}],"output":{"name":"str"}}],[11,"cause","","",40,{"inputs":[{"name":"tlsconnecterror"}],"output":{"name":"option"}}],[11,"from","","",40,{"inputs":[{"name":"tlsconnecterror"},{"name":"error"}],"output":{"name":"tlsconnecterror"}}],[11,"from","","",40,{"inputs":[{"name":"tlsconnecterror"},{"name":"sslerror"}],"output":{"name":"tlsconnecterror"}}],[11,"new","","Creates a new `TlsConnector` that will create a new `SslContext` before\ntrying to establish the TLS connection. The path to the CA file that the\ncontext will use needs to be provided.",39,{"inputs":[{"name":"tlsconnector"},{"name":"str"},{"name":"p"}],"output":{"name":"tlsconnector"}}],[11,"with_context","","Creates a new `TlsConnector` that will use the provided context to\ncreate the `SslStream` that will back the HTTP/2 connection.",39,{"inputs":[{"name":"tlsconnector"},{"name":"str"},{"name":"sslcontext"}],"output":{"name":"tlsconnector"}}],[11,"build_default_context","","Builds up a default `SslContext` instance wth TLS settings that the\nHTTP/2 spec mandates. The path to the CA file needs to be provided.",39,{"inputs":[{"name":"tlsconnector"},{"name":"path"}],"output":{"name":"result"}}],[6,"Stream","","",null,null],[6,"Err","","",null,null],[11,"connect","","",39,{"inputs":[{"name":"tlsconnector"}],"output":{"name":"result"}}],[8,"HttpConnectError","solicit::http::client","A marker trait for errors raised by attempting to establish an HTTP/2\nconnection.",null,null],[8,"HttpConnect","","A trait that can be implemented by structs that want to provide the\nfunctionality of establishing network connections for use by HTTP/2 connections.",null,null],[16,"Stream","","The type of the underlying transport stream that the `HttpConnection`s\nproduced by this `HttpConnect` implementation will be based on.",41,null],[16,"Err","","The type of the error that can be produced by trying to establish the\nconnection (i.e. calling the `connect` method).",41,null],[10,"connect","","Establishes a network connection that can be used by HTTP/2 connections.",41,{"inputs":[{"name":"httpconnect"}],"output":{"name":"result"}}],[11,"from","solicit::http","",2,{"inputs":[{"name":"httperror"},{"name":"e"}],"output":{"name":"httperror"}}],[11,"new","solicit::http::client","Creates a new `CleartextConnector` that will attempt to establish a connection to the given\nhost on port 80.",36,{"inputs":[{"name":"cleartextconnector"},{"name":"str"}],"output":{"name":"cleartextconnector"}}],[11,"with_port","","Creates a new `CleartextConnector` that will attempt to establish a connection to the given\nhost on the given port.",36,{"inputs":[{"name":"cleartextconnector"},{"name":"str"},{"name":"u16"}],"output":{"name":"cleartextconnector"}}],[11,"fmt","","",42,{"inputs":[{"name":"cleartextconnecterror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",42,{"inputs":[{"name":"cleartextconnecterror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",42,{"inputs":[{"name":"cleartextconnecterror"}],"output":{"name":"str"}}],[11,"cause","","",42,{"inputs":[{"name":"cleartextconnecterror"}],"output":{"name":"option"}}],[11,"from","","",42,{"inputs":[{"name":"cleartextconnecterror"},{"name":"error"}],"output":{"name":"cleartextconnecterror"}}],[6,"Stream","","",null,null],[6,"Err","","",null,null],[11,"connect","","Establishes a cleartext TCP connection based on the host and port.\nIf it is not possible, returns an `HttpError`.",36,{"inputs":[{"name":"cleartextconnector"}],"output":{"name":"result"}}],[11,"with_connection","","Creates a new `ClientConnection` that will use the given `HttpConnection`\nfor all its underlying HTTP/2 communication.",38,{"inputs":[{"name":"clientconnection"},{"name":"httpconnection"},{"name":"state"}],"output":{"name":"clientconnection"}}],[11,"scheme","","Returns the scheme of the underlying `HttpConnection`.",38,{"inputs":[{"name":"clientconnection"}],"output":{"name":"httpscheme"}}],[11,"init","","Performs the initialization of the `ClientConnection`.",38,{"inputs":[{"name":"clientconnection"}],"output":{"name":"httpresult"}}],[11,"start_request","","Starts a new request based on the given `RequestStream`.",38,{"inputs":[{"name":"clientconnection"},{"name":"requeststream"}],"output":{"name":"httpresult"}}],[11,"handle_next_frame","","Fully handles the next incoming frame. Events are passed on to the internal `session`\ninstance.",38,{"inputs":[{"name":"clientconnection"}],"output":{"name":"httpresult"}}],[11,"send_next_data","","Queues a new DATA frame onto the underlying `SendFrame`.",38,{"inputs":[{"name":"clientconnection"}],"output":{"name":"httpresult"}}],[11,"new","","Returns a new `ClientSession` associated to the given state.",43,{"inputs":[{"name":"clientsession"},{"name":"state"}],"output":{"name":"clientsession"}}],[11,"new_data_chunk","","",43,null],[11,"new_headers","","",43,{"inputs":[{"name":"clientsession"},{"name":"streamid"},{"name":"vec"}],"output":null}],[11,"end_of_stream","","",43,{"inputs":[{"name":"clientsession"},{"name":"streamid"}],"output":null}],[0,"server","solicit::http","The module contains a number of reusable components for implementing the server side of an\nHTTP/2 connection.",null,null],[3,"ServerSession","solicit::http::server","An implementation of the `Session` trait for a server-side HTTP/2 connection.",null,null],[3,"ServerConnection","","The struct provides a more convenient API for server-related functionality of an HTTP/2\nconnection, such as sending a response back to the client.",null,null],[12,"state","","The state of the session associated to this client connection. Maintains the status of the\nconnection streams.",44,null],[11,"new","","",45,{"inputs":[{"name":"serversession"},{"name":"state"}],"output":{"name":"serversession"}}],[11,"new_data_chunk","","",45,null],[11,"new_headers","","",45,{"inputs":[{"name":"serversession"},{"name":"streamid"},{"name":"vec"}],"output":null}],[11,"end_of_stream","","",45,{"inputs":[{"name":"serversession"},{"name":"streamid"}],"output":null}],[11,"with_connection","","Creates a new `ServerConnection` that will use the given `HttpConnection` for its\nunderlying HTTP/2 communication.",44,{"inputs":[{"name":"serverconnection"},{"name":"httpconnection"},{"name":"state"}],"output":{"name":"serverconnection"}}],[11,"scheme","","Returns the scheme of the underlying `HttpConnection`.",44,{"inputs":[{"name":"serverconnection"}],"output":{"name":"httpscheme"}}],[11,"init","","Initializes the `ServerConnection` by sending the server's settings and processing the\nclient's.\nIf the client does not provide a settings frame, returns an error.",44,{"inputs":[{"name":"serverconnection"}],"output":{"name":"httpresult"}}],[11,"handle_next_frame","","Fully handles the next incoming frame. Events are passed on to the internal `session`\ninstance.",44,{"inputs":[{"name":"serverconnection"}],"output":{"name":"httpresult"}}],[11,"start_response","","Starts a response on the stream with the given ID by sending the given headers.",44,{"inputs":[{"name":"serverconnection"},{"name":"vec"},{"name":"streamid"},{"name":"endstream"}],"output":{"name":"httpresult"}}],[11,"send_next_data","","Queues a new DATA frame onto the underlying `SendFrame`.",44,{"inputs":[{"name":"serverconnection"}],"output":{"name":"httpresult"}}],[6,"StreamId","solicit::http","An alias for the type that represents the ID of an HTTP/2 stream",null,null],[6,"Header","","An alias for the type that represents HTTP/2 headers. For now we only alias\nthe tuple of byte vectors instead of going with a full struct representation.",null,null],[6,"HttpResult","","A convenience `Result` type that has the `HttpError` type as the error\ntype and a generic Ok result type.",null,null],[17,"ALPN_PROTOCOLS","","A set of protocol names that the library should use to indicate that HTTP/2\nis supported during protocol negotiation (NPN or ALPN).\nWe include some of the drafts' protocol names, since there is basically no\ndifference for all intents and purposes (and some servers out there still\nonly officially advertise draft support).\nTODO: Eventually only use \"h2\".",null,null],[11,"fmt","","",2,{"inputs":[{"name":"httperror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",2,{"inputs":[{"name":"httperror"},{"name":"error"}],"output":{"name":"httperror"}}],[11,"fmt","","",2,{"inputs":[{"name":"httperror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",2,{"inputs":[{"name":"httperror"}],"output":{"name":"str"}}],[11,"cause","","",2,{"inputs":[{"name":"httperror"}],"output":{"name":"option"}}],[11,"eq","","",3,{"inputs":[{"name":"httpscheme"},{"name":"httpscheme"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"httpscheme"},{"name":"httpscheme"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"httpscheme"}],"output":{"name":"httpscheme"}}],[11,"fmt","","",3,{"inputs":[{"name":"httpscheme"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"as_bytes","","Returns a byte string representing the scheme.",3,null],[11,"clone","","",0,{"inputs":[{"name":"response"}],"output":{"name":"response"}}],[11,"new","","Creates a new `Response` with all the components already provided.",0,{"inputs":[{"name":"response"},{"name":"streamid"},{"name":"vec"},{"name":"vec"}],"output":{"name":"response"}}],[11,"status_code","","Gets the response status code from the pseudo-header. If the response\ndoes not contain the response as the first pseuo-header, an error is\nreturned as such a response is malformed.",0,{"inputs":[{"name":"response"}],"output":{"name":"httpresult"}}],[11,"clone","","",1,{"inputs":[{"name":"request"}],"output":{"name":"request"}}],[0,"client","solicit","The module contains implementations of HTTP/2 clients that could be\ndirectly used to access HTTP/2 servers, i.e. send requests and read\nresponses.",null,null],[3,"SimpleClient","solicit::client","A struct implementing a simple HTTP/2 client.",null,null],[3,"Client","","A struct representing an HTTP/2 client that receives responses to its\nrequests asynchronously. Additionally, this client can be cloned and all\nclones can issue (concurrently) requests to the server, using the same\nunderlying HTTP/2 connection.",null,null],[11,"with_connection","","Create a new `SimpleClient` instance that will use the given `HttpConnection`\nto communicate to the server.",46,{"inputs":[{"name":"simpleclient"},{"name":"httpconnection"},{"name":"string"}],"output":{"name":"httpresult"}}],[11,"with_connector","","A convenience constructor that first tries to establish an HTTP/2\nconnection by using the given connector instance (an implementation of\nthe `HttpConnect` trait).",46,{"inputs":[{"name":"simpleclient"},{"name":"c"}],"output":{"name":"httpresult"}}],[11,"request","","Send a request to the server. Blocks until the entire request has been\nsent.",46,null],[11,"get_response","","Gets the response for the stream with the given ID. If a valid stream ID\nis given, it blocks until a response is received.",46,{"inputs":[{"name":"simpleclient"},{"name":"streamid"}],"output":{"name":"httpresult"}}],[11,"get","","Performs a GET request on the given path. This is a shortcut method for\ncalling `request` followed by `get_response` for the returned stream ID.",46,null],[11,"post","","Performs a POST request on the given path.",46,null],[11,"clone","","",47,{"inputs":[{"name":"client"}],"output":{"name":"client"}}],[11,"drop","","",47,{"inputs":[{"name":"client"}],"output":null}],[11,"with_connector","","Creates a brand new HTTP/2 client. This means that a new HTTP/2\nconnection will be established behind the scenes. A thread is spawned\nto handle the connection in the background, so that the thread that\ncreates the client can use it asynchronously.",47,{"inputs":[{"name":"client"},{"name":"c"}],"output":{"name":"option"}}],[11,"request","","Issues a new request to the server.",47,null],[11,"get","","Issues a GET request to the server.",47,null],[11,"post","","Issues a POST request to the server.",47,null],[0,"server","solicit","The module contains a simple HTTP/2 server implementation.",null,null],[3,"ServerRequest","solicit::server","The struct represents a fully received request.",null,null],[12,"stream_id","","",48,null],[12,"headers","","",48,null],[12,"body","","",48,null],[3,"SimpleServer","","The struct implements a simple HTTP/2 server that allows users to register a request handler (a\ncallback taking a `ServerRequest` and returning a `Response`) which is run on all received\nrequests.",null,null],[11,"new","","Creates a new `SimpleServer` that will use the given `TransportStream` to communicate to\nthe client. Assumes that the stream is fully uninitialized -- no preface sent or read yet.",49,{"inputs":[{"name":"simpleserver"},{"name":"ts"},{"name":"h"}],"output":{"name":"httpresult"}}],[11,"handle_next","","Handles the next incoming frame, blocking to receive it if nothing is available on the\nunderlying stream.",49,{"inputs":[{"name":"simpleserver"}],"output":{"name":"httpresult"}}]],"paths":[[3,"Response"],[3,"Request"],[4,"HttpError"],[4,"HttpScheme"],[3,"DataFrame"],[4,"DataFlag"],[3,"StreamDependency"],[3,"HeadersFrame"],[4,"HeadersFlag"],[3,"SettingsFrame"],[4,"HttpSetting"],[4,"SettingsFlag"],[8,"Flag"],[8,"Frame"],[3,"RawFrame"],[8,"TransportStream"],[3,"TcpStream"],[3,"SslStream"],[3,"HttpConnection"],[3,"DataChunk"],[4,"HttpFrame"],[4,"SendStatus"],[4,"EndStream"],[8,"SendFrame"],[8,"ReceiveFrame"],[3,"DefaultStream"],[4,"StreamState"],[4,"StreamDataError"],[4,"StreamDataChunk"],[8,"Session"],[8,"SessionState"],[8,"Stream"],[3,"StreamIter"],[3,"DefaultSessionState"],[8,"DataPrioritizer"],[3,"SimplePrioritizer"],[3,"CleartextConnector"],[3,"RequestStream"],[3,"ClientConnection"],[3,"TlsConnector"],[4,"TlsConnectError"],[8,"HttpConnect"],[3,"CleartextConnectError"],[3,"ClientSession"],[3,"ServerConnection"],[3,"ServerSession"],[3,"SimpleClient"],[3,"Client"],[3,"ServerRequest"],[3,"SimpleServer"]]};
initSearch(searchIndex);
